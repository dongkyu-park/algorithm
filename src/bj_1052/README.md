
N = 100, K = 1 이라면,

1. 100개
2. 50개 -> 2L
3. 25개 -> 4L
4. 13개(12+1) -> 8L 4개 구매
5. 7개(6+1) -> 16L 8개 구매
6. 4개(3+1) -> 32L 16개 구매
7. 2개 -> 64L
8. 1개 -> 128L

물을 나누던 중 남은 물병의 갯수가 K개 이하로 도달했다면 물병을 더 이상 구매하지 않아도 된다.

----------------------------------------

접근을 잘못 했다. 처음 100개의 물병에서 계속 반감해 나가면서
물병이 1개가 남으면 무조건 물병을 추가 구매해야 한다는 식으로 생각했는데,

위와 같은 방법으로 풀어 버리면 오답이 된다.

물병을 구매하지 않고 가지고 있는 물병 100개를 최소한의 단위로 쪼개면, 64L, 32L, 4L 3개로 쪼갤 수 있다.
따라서 K값이 3이상 이라면, 추가로 구매해야 하는 물병의 갯수는 0개이다.

-------------------------------------------

검색 후 2진법 변환을 이용한 방법을 보고 Main2로 다시 풀이.

N = 100인 경우 64, 32, 4로 분해할 수 있다. 이는 세 개의 물병에 각각 64L, 32L, 4L가 들어있는 것과 같다.
만약 K값이 3이상이라면 물병을 추가할 필요없이 0을 리턴하고 종료하면 된다.

물병을 합쳐 최소한의 갯수로 만드는 행위가 결국 10진수를 2진수로 바꾸었을 때 2진수의 값이 1인 자리만을 센 것과 같기 때문에
10진수를 2진수로 변환하고, 높은 비트부터 읽어가며 비트값이 1인 자리의 10진값을 Stack에 넣어주면
64, 32, 4 의 순서로 저장이 된다.

이는 물병이 100개일 경우, 물병의 추가 구매없이 최소한으로 줄일 수 있는 갯수가 3개라는 뜻이기 때문에, K가 3이상일 경우 0을 리턴하면 되고,
K가 3보다 작다면, 스택에서 가장 마지막에 추가 된 낮은 비트의 수 2개를 뽑아 차이를 구한다. 32 - 4 = 28. 
물병 2개를 합치기 위해선 제일 작은 4L짜리 물병에 28L만큼의 물이 필요하다는 뜻이 된다.
따라서 구매해야 하는 물병의 갯수에 28개를 더해준 뒤, 32L짜리 물병이 2개가 되었으므로 2번째로 pop된 값에 *2를 하여 Stack에 추가 해준다.

이를 반복하여 Stack을 점점 줄여나가고, Stack에 저장 된 값의 갯수가 K값과 같아 진다면, 반복 호출을 종료하고 구매해야 하는 물병의 갯수를 리턴한다.

